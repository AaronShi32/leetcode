Prime 解锁题目

[A][M: 前序非递归遍历]285.Inorder Successor in BST
[E: 按起始时间排序 + pq + 遍历 + 比较条件: interval[i].start < pq.peek()]252.MeetingRooms
[M: 按起始时间排序 + pq + 遍历 + 比较条件: interval[i].start < pq.peek() + 计数]253 Meeting Rooms II
[M: Map 统计次数, put 时候检查 map.size() > K, remove or count -1 时得出 max]340.Longest Substring with At Most K Distinct Characters
[A: for(int i = t[i] - '0' + 1; i <= limit; i++), int[10] + 4 个 for][M: O(4 * 10) + O(10): G家follow up]681. Next Closest Time
[A][H: BST 中序非递归遍历, 记录 pre gap]272. Closest Binary Search Tree Value II
[E: 递归 dfs]339. Nested List Weight Sum
            /364. Nested List Weight Sum II
[H: 区间找补集, 全部加到 pq 中, 先 poll() 一个作为标杆, 比较合并]759. Employee Free Time
[M: 先找后消循环]723.Candy Crush
[E]243. Shortest Word Distance [双指针: 时间 O(N) 空间 O(1)]
  \244. Shortest Word Distance II [哈希表 + merge sort 比较: 时间 O(N) 空间 O(N)]
  \245. Shortest Word Distance III[双指针 + 标记重复: 时间 O(N) 空间 O(N)]
  https://www.cnblogs.com/grandyang/p/5187041.html

[M]280.Wiggle Sort [先排序再swap: int i = 1; i + 1 < nums.length; i += 2]
   324.Wiggle Sort II[先排序再倒序填入数组: nums[i] = (i % 2 == 1)? temp[--j] ? temp[--k]]
   75. Sort Colors[one-pass 不太理解, two-pass 先计数然后填满, 不能直接排序]

[M: 加入根, 三个递归, find left -> leafs -> right]545.Boundary of Binary Tree
