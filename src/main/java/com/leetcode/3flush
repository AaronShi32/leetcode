# LinkedList
[A/TC: O(1)]725. Split Linked List in Parts
[A/TC: O(1) one pass]328. Odd Even Linked List
[R: leaf node condition]109. Convert Sorted List to Binary Search Tree
[A/TC: O(1)]86. Partition List
[A][P 3指针加反转]92. Reverse Linked List II
[A 奇数链merge条件][涉及到的解法比较好, 知识点比较多]143. Reorder List
[A/TC: O(nlogn)][归并排序]148. Sort List
[R-][区间反转]25.Reverse Nodes in k-Group

# Backtracking
[visited, 重复 (条件)continue, 排序才能 i - 1]Permutations II, Subsets II
[A][A][reuse]Combination Sum
[A]Generate Parentheses
[A/2 dfs 返回 false 的案例/visited]Word Search, Word Search II
[memorise]Word Break II


# BFS
# BFS 不仅可以用 queue.isEmpty() 做外循环条件, 还可以用解的状态做, 未达到某种状态说明还未搜索到
[BFS, 改变某位字符的使用]784. Letter Case Permutation
[外层条件] 17. Letter Combinations of a Phone Number
[树的层次遍历问题集合]513. Find Bottom Left Tree Value[A: BFS from right to left, last node is leftmost]
                    /199. Binary Tree Right Side View[A: BFS from right to left]
                    /515. Find Largest Value in Each Tree Row
                    /111. Minimum Depth of Binary Tree
                    /103. Binary Tree Zigzag Level Order Traversal
                    /637. Average of Levels in Binary Tree
[前处理 Map 再 BFS] 815.Bus Routes

# Graph
[Topological Sorting 拓扑排序: 生成图, 统计入度, 选择入度为0的点进行BFS]207. Course Schedule
[Topological Sorting 拓扑排序: 记录值]285. Course Schedule II

# DFS
[find(记录节点和parent映射, Map) + dfs(三个方向)]863. All Nodes Distance K in Binary Tree
[FloodFill算法]200. Number of Islands[A if(){dfs(); ans++}]
              /695. Max Area Of Island 用 area = dfs(...) 标记返回, 是 dfs 返回值的好案例
              /463. Island Perimeter 计算边数: islands * 4 - neighbours * 2

# BST
[中序遍历解决一切]285.Inorder Successor in BST
                /[A, 递归会高效一些]783. Minimum Distance Between BST Nodes
                /[A]230. Kth Smallest Element in a BST
                /98. Validate Binary Search Tree(pre != null && pre.val > root.val)

# Tree
[递归/BFS]101.Symmetric Tree
[A][map + queue]235. Lowest Common Ancestor
[路径和系列:
112. boolean 递归, 三句(2判断, 1返回, 用 ||)
113. List<List<Integer>> dfs, 用 if/else, 必须 remove(size() - 1)
437
124]112. Path Sum/113. Path Sum II/437. Path Sum III/124.Binary Tree Maximum Path Sum
[BFS: ColumnTreeNode + Map<column, List<TreeNode>>] 314.Binary Tree Vertical Order Traversal


# Base 基础算法
[704.Binary Search]

# String
[while, set, i, j, 从头remove, 加入时取max]3.Longest Substring Without Repeating Characters
[A: Array.sort(String[]) 长度由小到大][排序, 首尾相比]14.Longest Common Prefix

# Reverse 类型
[r = r * 10 + x % 10]7. Reverse Integer

# 应用类
[int step = x & -x]751. IP to CIDR

# 双指针 Two Point
[Sum 类, 先排序, 降维, 跳重]15. 3Sum[A 优化点 nums[i] > 0 break]
                          /16. 3Sum Closest(判断closest并记录)[A 优化点: 跳重 98.51%]
                          /18. 4Sum (四次跳重)
                          /925. Long Name Pressed(双指针 + need差量)

# Array
[双 Math.max 记录 当前和起点(Math.max(cur + next, next), 记录最大和)]53. Maximum Subarray

# 区间合并
[先排序, 遍历(start < end 取 Max(end), start > end 生成合并区间), add 最后一个区间]56.Merge Intervals
[3个遍历, 1. intervals.get(i).end < newInterval.start 2. intervals.get(i).start <= newInterval.end]57.Insert Interval
[]621. Task Scheduler

# Top K
[Map + (Array(List<Integer>[], O(n)) or PQ(按次数降序, O(nlogn)))]347. Top K Frequent Elements
[Map + PQ(比较条件 a.getValue() == b.getValue() ? b.getKey().compareTo(a.getKey()): (b.getValue() - a.getValue()))]692. Top K Frequent Words
[]658. Find K Closest Elements

# 第 K 个
[A][QuickSelect 快选算法(partition): poivt = nums[(left + right)/2], while 判断 no equal, k <= right, k >= left]215.Kth Largest Element in an Array/Kth Smaller Element in an Array